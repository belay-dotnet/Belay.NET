// Copyright 2025 Belay.NET Contributors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Concurrent;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Belay.Attributes;
using Microsoft.Extensions.Logging;

namespace Belay.Core.Execution
{
    /// <summary>
    /// Executor for methods decorated with the [Teardown] attribute.
    /// Handles automatic deployment and execution of teardown methods during device cleanup.
    /// </summary>
    public sealed class TeardownExecutor : BaseExecutor
    {
        private readonly ConcurrentHashSet<string> _registeredTeardownMethods;
        private readonly object _teardownLock = new object();
        private bool _teardownInProgress = false;

        /// <summary>
        /// Initializes a new instance of the <see cref="TeardownExecutor"/> class.
        /// </summary>
        /// <param name="device">The device to execute methods on.</param>
        /// <param name="logger">The logger for diagnostic information.</param>
        public TeardownExecutor(Device device, ILogger<TeardownExecutor> logger)
            : base(device, logger)
        {
            _registeredTeardownMethods = new ConcurrentHashSet<string>();
        }

        /// <summary>
        /// Executes a method decorated with [Teardown] attribute.
        /// Teardown methods are typically executed during cleanup or disconnect operations.
        /// </summary>
        /// <typeparam name="T">The return type of the method.</typeparam>
        /// <param name="method">The method to execute.</param>
        /// <param name="parameters">The parameters to pass to the method.</param>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        /// <returns>The result of the method execution.</returns>
        public async Task<T> ExecuteTeardownAsync<T>(MethodInfo method, object?[]? parameters = null, CancellationToken cancellationToken = default)
        {
            var teardownAttribute = method.GetAttribute<TeardownAttribute>();
            if (teardownAttribute == null)
                throw new InvalidOperationException($"Method {method.Name} is not decorated with [Teardown] attribute");

            Logger.LogDebug("Executing teardown method {MethodName}", method.Name);

            try
            {
                var result = await ExecuteAsync<T>(method, parameters, cancellationToken).ConfigureAwait(false);
                
                Logger.LogDebug("Teardown method {MethodName} completed successfully", method.Name);
                return result;
            }
            catch (Exception ex)
            {
                // Teardown methods should be resilient - log errors but don't throw
                // This ensures cleanup can continue even if individual teardown methods fail
                Logger.LogError(ex, "Teardown method {MethodName} failed, but continuing cleanup", method.Name);
                
                return default(T)!;
            }
        }

        /// <summary>
        /// Executes a method decorated with [Teardown] attribute without returning a value.
        /// </summary>
        /// <param name="method">The method to execute.</param>
        /// <param name="parameters">The parameters to pass to the method.</param>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        public async Task ExecuteTeardownAsync(MethodInfo method, object?[]? parameters = null, CancellationToken cancellationToken = default)
        {
            await ExecuteTeardownAsync<object>(method, parameters, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Executes all teardown methods found on the specified type in reverse order.
        /// </summary>
        /// <param name="type">The type to scan for teardown methods.</param>
        /// <param name="instance">The instance to execute methods on (null for static methods).</param>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        public async Task ExecuteAllTeardownMethodsAsync(Type type, object? instance = null, CancellationToken cancellationToken = default)
        {
            lock (_teardownLock)
            {
                if (_teardownInProgress)
                {
                    Logger.LogWarning("Teardown already in progress, skipping duplicate teardown request");
                    return;
                }
                _teardownInProgress = true;
            }

            try
            {
                Logger.LogDebug("Scanning type {TypeName} for teardown methods", type.Name);

                var teardownMethods = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static)
                    .Where(m => m.HasAttribute<TeardownAttribute>())
                    .OrderByDescending(m => m.GetAttribute<TeardownAttribute>()!.Order) // Execute in reverse order
                    .ThenByDescending(m => m.Name)
                    .ToList();

                if (teardownMethods.Count == 0)
                {
                    Logger.LogDebug("No teardown methods found on type {TypeName}", type.Name);
                    return;
                }

                Logger.LogInformation("Found {Count} teardown methods on type {TypeName}", teardownMethods.Count, type.Name);

                foreach (var method in teardownMethods)
                {
                    if (method.IsStatic || instance != null)
                    {
                        await ExecuteTeardownAsync(method, null, cancellationToken).ConfigureAwait(false);
                    }
                    else
                    {
                        Logger.LogWarning("Skipping instance teardown method {MethodName} because no instance was provided", 
                            method.Name);
                    }
                }

                Logger.LogInformation("Completed execution of {Count} teardown methods on type {TypeName}", 
                    teardownMethods.Count, type.Name);
            }
            finally
            {
                lock (_teardownLock)
                {
                    _teardownInProgress = false;
                }
            }
        }

        /// <summary>
        /// Registers teardown methods from a type without executing them.
        /// This allows the executor to track which teardown methods should be called during cleanup.
        /// </summary>
        /// <param name="type">The type to register teardown methods from.</param>
        public void RegisterTeardownMethods(Type type)
        {
            Logger.LogDebug("Registering teardown methods from type {TypeName}", type.Name);

            var teardownMethods = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static)
                .Where(m => m.HasAttribute<TeardownAttribute>())
                .ToList();

            foreach (var method in teardownMethods)
            {
                var methodKey = method.GetDeviceMethodName();
                if (_registeredTeardownMethods.Add(methodKey))
                {
                    Logger.LogDebug("Registered teardown method {MethodName}", method.Name);
                }
            }

            Logger.LogInformation("Registered {Count} teardown methods from type {TypeName}", 
                teardownMethods.Count, type.Name);
        }

        /// <summary>
        /// Gets the list of registered teardown methods.
        /// </summary>
        /// <returns>A collection of registered teardown method keys.</returns>
        public IReadOnlyCollection<string> GetRegisteredTeardownMethods()
        {
            return _registeredTeardownMethods.ToArray();
        }

        /// <summary>
        /// Clears all registered teardown methods.
        /// </summary>
        public void ClearRegisteredTeardownMethods()
        {
            var count = _registeredTeardownMethods.Count;
            _registeredTeardownMethods.Clear();
            Logger.LogDebug("Cleared {Count} registered teardown methods", count);
        }

        /// <summary>
        /// Checks if teardown is currently in progress.
        /// </summary>
        /// <returns>True if teardown is in progress, false otherwise.</returns>
        public bool IsTeardownInProgress()
        {
            lock (_teardownLock)
            {
                return _teardownInProgress;
            }
        }

        /// <inheritdoc />
        protected override async Task<string> GeneratePythonCodeAsync(MethodInfo method, string deviceMethodName, CancellationToken cancellationToken)
        {
            var teardownAttribute = method.GetAttribute<TeardownAttribute>()!;
            
            Logger.LogDebug("Generating Python code for teardown method {MethodName} (order: {Order})", 
                method.Name, teardownAttribute.Order);

            var codeBuilder = new StringBuilder();
            
            // Add method signature
            var parameters = method.GetParameters();
            var paramNames = parameters.Length > 0 
                ? string.Join(", ", parameters.Select(p => p.Name))
                : "";

            codeBuilder.AppendLine($"def {deviceMethodName}({paramNames}):");
            codeBuilder.AppendLine("    \"\"\"");
            codeBuilder.AppendLine($"    Teardown method: {method.Name} (order: {teardownAttribute.Order})");
            codeBuilder.AppendLine($"    Generated from: {method.DeclaringType?.Name}.{method.Name}");
            codeBuilder.AppendLine("    \"\"\"");

            // Generate method body for teardown operations
            var pythonBody = await GenerateTeardownMethodBodyAsync(method, cancellationToken).ConfigureAwait(false);
            
            // Indent the body
            var indentedBody = string.Join("\n", pythonBody.Split('\n').Select(line => 
                string.IsNullOrWhiteSpace(line) ? line : $"    {line}"));
            
            codeBuilder.AppendLine(indentedBody);

            // Add teardown metadata as comments
            codeBuilder.AppendLine($"# Teardown order: {teardownAttribute.Order}");
            codeBuilder.AppendLine($"# Method signature: {method.GetSignatureHash()}");

            return codeBuilder.ToString();
        }

        /// <inheritdoc />
        protected override Task ValidateMethodExecutionAsync(MethodInfo method, CancellationToken cancellationToken)
        {
            if (!method.HasAttribute<TeardownAttribute>())
            {
                throw new NotSupportedException($"Method {method.Name} must be decorated with [Teardown] attribute to be executed by TeardownExecutor");
            }

            var teardownAttribute = method.GetAttribute<TeardownAttribute>()!;
            
            // Validate order value
            if (teardownAttribute.Order < 0)
            {
                throw new ArgumentException($"Invalid order value {teardownAttribute.Order} for teardown method {method.Name}");
            }

            // Teardown methods should typically not have complex return types or throw exceptions
            var returnType = method.ReturnType;
            if (returnType != typeof(void) && returnType != typeof(Task) && 
                !returnType.IsValueType && returnType != typeof(string))
            {
                Logger.LogWarning("Teardown method {MethodName} has complex return type {ReturnType} - " +
                    "teardown methods should typically return void or simple types", 
                    method.Name, returnType.Name);
            }

            return Task.CompletedTask;
        }

        /// <summary>
        /// Generates the Python method body for teardown operations.
        /// </summary>
        /// <param name="method">The method to generate body for.</param>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        /// <returns>The Python method body code.</returns>
        private async Task<string> GenerateTeardownMethodBodyAsync(MethodInfo method, CancellationToken cancellationToken)
        {
            await Task.CompletedTask; // Placeholder for async pattern
            
            // Teardown methods typically perform cleanup tasks
            var codeBuilder = new StringBuilder();
            
            codeBuilder.AppendLine("# Teardown method implementation");
            codeBuilder.AppendLine($"print('Executing teardown: {method.Name}')");
            codeBuilder.AppendLine("try:");
            
            var returnType = method.ReturnType;
            
            if (returnType == typeof(void) || returnType == typeof(Task))
            {
                codeBuilder.AppendLine("    pass  # TODO: Implement teardown logic");
                codeBuilder.AppendLine("    print('Teardown completed successfully')");
            }
            else if (returnType == typeof(bool))
            {
                codeBuilder.AppendLine("    # TODO: Implement teardown logic");
                codeBuilder.AppendLine("    print('Teardown completed successfully')");
                codeBuilder.AppendLine("    return True");
            }
            else if (returnType == typeof(string))
            {
                codeBuilder.AppendLine("    # TODO: Implement teardown logic");
                codeBuilder.AppendLine($"    return 'Teardown {method.Name} completed'");
            }
            else
            {
                codeBuilder.AppendLine("    # TODO: Implement teardown logic");
                codeBuilder.AppendLine("    return None");
            }
            
            codeBuilder.AppendLine("except Exception as e:");
            codeBuilder.AppendLine($"    print('Teardown {method.Name} error:', e)");
            codeBuilder.AppendLine("    # Teardown methods should be resilient to errors");
            
            if (returnType == typeof(bool))
            {
                codeBuilder.AppendLine("    return False");
            }
            else if (returnType != typeof(void) && returnType != typeof(Task))
            {
                codeBuilder.AppendLine("    return None");
            }
            
            return codeBuilder.ToString();
        }

        /// <summary>
        /// Overrides the base execution to add resilient error handling for teardown methods.
        /// </summary>
        protected override async Task<T> ExecuteDeployedMethodAsync<T>(DeployedMethod deployedMethod, object?[]? parameters, CancellationToken cancellationToken)
        {
            try
            {
                return await base.ExecuteDeployedMethodAsync<T>(deployedMethod, parameters, cancellationToken).ConfigureAwait(false);
            }
            catch (DeviceExecutionException ex)
            {
                // For teardown methods, we want to be resilient to execution errors
                // Log the error but return a default value to allow cleanup to continue
                Logger.LogError(ex, "Teardown method {DeviceMethodName} failed during execution", deployedMethod.DeviceMethodName);
                return default(T)!;
            }
        }
    }
}