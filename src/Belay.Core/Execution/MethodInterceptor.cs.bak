// Copyright 2025 Belay.NET Contributors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Concurrent;
using System.Collections.Immutable;
using System.Reflection;
using System.Threading;
using System.Threading.Tasks;
using Belay.Attributes;
using Microsoft.Extensions.Logging;

namespace Belay.Core.Execution
{
    /// <summary>
    /// Provides method interception capabilities for attribute-based method execution.
    /// </summary>
    public sealed class MethodInterceptor
    {
        private readonly Device _device;
        private readonly TaskExecutor _taskExecutor;
        private readonly SetupExecutor _setupExecutor;
        private readonly ThreadExecutor _threadExecutor;
        private readonly TeardownExecutor _teardownExecutor;
        private readonly ILogger<MethodInterceptor> _logger;
        private readonly ConcurrentDictionary<MethodInfo, object> _interceptedMethods;

        /// <summary>
        /// Initializes a new instance of the <see cref="MethodInterceptor"/> class.
        /// </summary>
        /// <param name="device">The device to execute methods on.</param>
        /// <param name="taskExecutor">The executor for [Task] attributes.</param>
        /// <param name="setupExecutor">The executor for [Setup] attributes.</param>
        /// <param name="threadExecutor">The executor for [Thread] attributes.</param>
        /// <param name="teardownExecutor">The executor for [Teardown] attributes.</param>
        /// <param name="logger">The logger for diagnostic information.</param>
        public MethodInterceptor(
            Device device,
            TaskExecutor taskExecutor,
            SetupExecutor setupExecutor,
            ThreadExecutor threadExecutor,
            TeardownExecutor teardownExecutor,
            ILogger<MethodInterceptor> logger)
        {
            _device = device ?? throw new ArgumentNullException(nameof(device));
            _taskExecutor = taskExecutor ?? throw new ArgumentNullException(nameof(taskExecutor));
            _setupExecutor = setupExecutor ?? throw new ArgumentNullException(nameof(setupExecutor));
            _threadExecutor = threadExecutor ?? throw new ArgumentNullException(nameof(threadExecutor));
            _teardownExecutor = teardownExecutor ?? throw new ArgumentNullException(nameof(teardownExecutor));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _interceptedMethods = new ConcurrentDictionary<MethodInfo, object>();
        }

        /// <summary>
        /// Intercepts a method call and routes it to the appropriate executor based on its attributes.
        /// </summary>
        /// <typeparam name="T">The return type of the method.</typeparam>
        /// <param name="method">The method being called.</param>
        /// <param name="parameters">The parameters passed to the method.</param>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        /// <returns>The result of the method execution.</returns>
        public async Task<T> InterceptAsync<T>(MethodInfo method, object?[]? parameters = null, CancellationToken cancellationToken = default)
        {
            ArgumentNullException.ThrowIfNull(method);

            _logger.LogDebug("Intercepting method {MethodName} with return type {ReturnType}", 
                method.Name, typeof(T).Name);

            // Determine which executor to use based on attributes
            if (method.HasAttribute<TaskAttribute>())
            {
                return await _taskExecutor.ExecuteTaskAsync<T>(method, parameters, cancellationToken).ConfigureAwait(false);
            }
            else if (method.HasAttribute<SetupAttribute>())
            {
                return await _setupExecutor.ExecuteSetupAsync<T>(method, parameters, cancellationToken).ConfigureAwait(false);
            }
            else if (method.HasAttribute<ThreadAttribute>())
            {
                // Thread methods don't return values directly - they start background threads
                var runningThread = await _threadExecutor.StartThreadAsync(method, parameters, cancellationToken).ConfigureAwait(false);
                
                // For thread methods, we return thread information or default value
                if (typeof(T) == typeof(RunningThread))
                {
                    return (T)(object)runningThread;
                }
                else
                {
                    return default(T)!;
                }
            }
            else if (method.HasAttribute<TeardownAttribute>())
            {
                return await _teardownExecutor.ExecuteTeardownAsync<T>(method, parameters, cancellationToken).ConfigureAwait(false);
            }
            else
            {
                // No recognized attribute - cannot intercept
                throw new NotSupportedException($"Method {method.Name} does not have a recognized Belay attribute ([Task], [Setup], [Thread], or [Teardown])");
            }
        }

        /// <summary>
        /// Intercepts a method call without returning a value.
        /// </summary>
        /// <param name="method">The method being called.</param>
        /// <param name="parameters">The parameters passed to the method.</param>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        public async Task InterceptAsync(MethodInfo method, object?[]? parameters = null, CancellationToken cancellationToken = default)
        {
            await InterceptAsync<object>(method, parameters, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Registers an intercepted method for future reference.
        /// </summary>
        /// <param name="method">The method to register.</param>
        /// <param name="interceptedInstance">The intercepted instance (if any).</param>
        public void RegisterInterceptedMethod(MethodInfo method, object? interceptedInstance = null)
        {
            _interceptedMethods.TryAdd(method, interceptedInstance ?? new object());
            
            _logger.LogDebug("Registered intercepted method {MethodName}", method.Name);
        }

        /// <summary>
        /// Gets all registered intercepted methods.
        /// </summary>
        /// <returns>A collection of intercepted method information.</returns>
        public IReadOnlyDictionary<MethodInfo, object> GetInterceptedMethods()
        {
            return _interceptedMethods.ToImmutableDictionary();
        }

        /// <summary>
        /// Checks if a method has been registered for interception.
        /// </summary>
        /// <param name="method">The method to check.</param>
        /// <returns>True if the method is registered for interception, false otherwise.</returns>
        public bool IsMethodIntercepted(MethodInfo method)
        {
            return _interceptedMethods.ContainsKey(method);
        }

        /// <summary>
        /// Scans a type for methods with Belay attributes and prepares them for interception.
        /// </summary>
        /// <param name="type">The type to scan.</param>
        /// <returns>The number of methods prepared for interception.</returns>
        public int PrepareTypeForInterception(Type type)
        {
            _logger.LogDebug("Scanning type {TypeName} for interceptable methods", type.Name);

            var interceptableMethods = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static)
                .Where(m => HasBelayAttribute(m))
                .ToList();

            foreach (var method in interceptableMethods)
            {
                RegisterInterceptedMethod(method);
                
                var attributes = GetBelayAttributes(method);
                _logger.LogDebug("Prepared method {MethodName} for interception with attributes: {Attributes}", 
                    method.Name, string.Join(", ", attributes));
            }

            _logger.LogInformation("Prepared {Count} methods for interception from type {TypeName}", 
                interceptableMethods.Count, type.Name);

            return interceptableMethods.Count;
        }

        /// <summary>
        /// Executes all setup methods found on a type.
        /// </summary>
        /// <param name="type">The type to execute setup methods for.</param>
        /// <param name="instance">The instance to use for non-static methods.</param>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        public async Task ExecuteSetupMethodsAsync(Type type, object? instance = null, CancellationToken cancellationToken = default)
        {
            await _setupExecutor.ExecuteAllSetupMethodsAsync(type, instance, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Executes all teardown methods found on a type.
        /// </summary>
        /// <param name="type">The type to execute teardown methods for.</param>
        /// <param name="instance">The instance to use for non-static methods.</param>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        public async Task ExecuteTeardownMethodsAsync(Type type, object? instance = null, CancellationToken cancellationToken = default)
        {
            await _teardownExecutor.ExecuteAllTeardownMethodsAsync(type, instance, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Stops all running background threads started by this interceptor.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        /// <returns>The number of threads that were stopped.</returns>
        public async Task<int> StopAllBackgroundThreadsAsync(CancellationToken cancellationToken = default)
        {
            return await _threadExecutor.StopAllThreadsAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Gets information about all running background threads.
        /// </summary>
        /// <returns>A collection of running thread information.</returns>
        public IReadOnlyCollection<RunningThread> GetRunningThreads()
        {
            return _threadExecutor.GetRunningThreads();
        }

        /// <summary>
        /// Clears all deployed methods and reset execution state.
        /// This is typically called when disconnecting from a device.
        /// </summary>
        /// <param name="cancellationToken">Cancellation token to cancel the operation.</param>
        public async Task ResetAsync(CancellationToken cancellationToken = default)
        {
            _logger.LogInformation("Resetting method interceptor state");

            // Stop all background threads
            await StopAllBackgroundThreadsAsync(cancellationToken).ConfigureAwait(false);

            // Clear all caches
            await _taskExecutor.ClearCacheAsync(cancellationToken).ConfigureAwait(false);
            await _setupExecutor.ClearCacheAsync(cancellationToken).ConfigureAwait(false);
            await _threadExecutor.ClearCacheAsync(cancellationToken).ConfigureAwait(false);
            await _teardownExecutor.ClearCacheAsync(cancellationToken).ConfigureAwait(false);

            // Reset setup state
            _setupExecutor.ResetSetupState();

            // Clear intercepted methods
            _interceptedMethods.Clear();

            _logger.LogInformation("Method interceptor state reset completed");
        }

        /// <summary>
        /// Checks if a method has any Belay attribute.
        /// </summary>
        /// <param name="method">The method to check.</param>
        /// <returns>True if the method has a Belay attribute, false otherwise.</returns>
        private static bool HasBelayAttribute(MethodInfo method)
        {
            return method.HasAttribute<TaskAttribute>() ||
                   method.HasAttribute<SetupAttribute>() ||
                   method.HasAttribute<ThreadAttribute>() ||
                   method.HasAttribute<TeardownAttribute>();
        }

        /// <summary>
        /// Gets the names of all Belay attributes on a method.
        /// </summary>
        /// <param name="method">The method to get attributes from.</param>
        /// <returns>A collection of attribute names.</returns>
        private static IEnumerable<string> GetBelayAttributes(MethodInfo method)
        {
            var attributes = new List<string>();

            if (method.HasAttribute<TaskAttribute>())
                attributes.Add("Task");
            if (method.HasAttribute<SetupAttribute>())
                attributes.Add("Setup");
            if (method.HasAttribute<ThreadAttribute>())
                attributes.Add("Thread");
            if (method.HasAttribute<TeardownAttribute>())
                attributes.Add("Teardown");

            return attributes;
        }
    }
}